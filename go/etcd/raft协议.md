# 选主 #  
一个集群有一个主节点对外提供服务。主节点失联（通过心跳同步数据），集群选举一个新的节点。  
选举步骤：  
  1.集群初始化时，每个节点都为Follower  
  2.Follower一定时间未能收到主节点心跳，变为Candidate，并发起一次选举  
  3.收到过半赞同，选举成功，否则失败（不足半数选，选举超时）  
  4.若本轮未选出主节点，将进行下一轮选举（多个节点同时选举，且所有节点均为获得过半选票）  
  5.Candidate节点收到来自主节点的信息后，会立即终止选举过程，进入Follower角色
# 日志复制 #  
主节点将每次操作形成日志条目，并持久化到本地磁盘，然后通过网络IO发送给其他节点。  
其他节点根据日志的逻辑时钟(TERM)和日志编号(INDEX)来判断是否将该日志记录持久化到本地。  
当主节点收到包括自己在内超过半数节点成功返回，那么认为该日志是可提交的(committed），  
并将日志输入到状态机，将结果返回给客户端。  
**每次选主都会形成一个唯一的TERM编号，相当于逻辑时钟。每一条日志都有全局唯一的编号。**  
主节点通过网络IO向其他节点追加日志。若某节点收到日志追加的消息，首先判断该日志的TERM是否过期，  
以及该日志条目的INDEX是否比当前以及提交的日志的INDEX跟早。   
若已过期，或者比提交的日志更早，那么就拒绝追加，并返回该节点当前的已提交的日志的编号。否则，将日志追加，并返回成功。
当主节点收到其他节点关于日志追加的回复后，若发现有拒绝，则根据该节点返回的已提交日志编号，发生其编号下一条日志。  
主节点像其他节点同步日志，还作了拥塞控制。具体地说，主节点发现日志复制的目标节点拒绝了某次日志追加消息，将进入日志探测阶段，  
一条一条发送日志，直到目标节点接受日志，然后进入快速复制阶段，可进行批量日志追加。
按照日志复制的逻辑，我们可以看到，集群中慢节点不影响整个集群的性能。  
另外一个特点是，数据只从主节点复制到Follower节点，这样大大简化了逻辑流程。  

# 安全性 #  
选主和日志复制不能保证节点间数据一致。  
某个节点挂掉，重启后被选为主节点，他会缺失重启之前的日志。  
它将自己日志复制给其他节点，会将集群已经提交的日志给覆盖掉。？？  

其他协议解决这个问题的办法是，新当选的主节点会询问其他节点，和自己数据对比，确定出集群已提交数据，然后将缺失的数据同步过来。这个方案有明显缺陷，增加了集群恢复服务的时间（集群在选举阶段不可服务），并且增加了协议的复杂度。

Raft解决的办法是，在选主逻辑中，对能够成为主的节点加以限制，确保选出的节点已定包含了集群已经提交的所有日志。如果新选出的主节点已经包含了集群所有提交的日志，那就不需要从和其他节点比对数据了。简化了流程，缩短了集群恢复服务的时间。

只要仍然有超过半数节点存活，这样的主一定能够选出。因为已经提交的日志必然被集群中超过半数节点持久化，显然前一个主节点提交的最后一条日志也被集群中大部分节点持久化。当主节点挂掉后，集群中仍有大部分节点存活，那这存活的节点中一定存在一个节点包含了已经提交的日志了。
