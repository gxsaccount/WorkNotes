# 铺垫知识 #
## 1.内存相关知识 ##  
在C++中，内存分成5个区，他们分别是**栈、（堆、自由存储区）、全局/静态存储区、常量存储区**  
1.栈，编译器在需要时分配，不需要时候自动清除的变量存储区。里面的变量通常是局部变量、函数参数等。  
2.堆，new分配的内存块，释放delete控制。没有delete程序结束后，操作系统会自动回收。  
  自由存储区，由malloc等分配的内存块，和堆是十分相似的，用free释放。  
3.全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分，他们共同占用同一块内存区。  
4.常量存储区，存放的是常量，不允许修改（通过非正当手段也可以修改）  

5.每个进程有0~2^系统位数-1的虚拟空间地址.32位系统共有4GB,linux中内核空间有1GB,用户空间3G.windows各2G.

区域名称|区域存放内容
-|-
代码段| 存放函数体的二进制代码,直接的操作数(int a = 4;)
只读常量区| 存放常量
全局区（静态区）（static）| 全局变量和静态变量,初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域
全局区（bss段）| 存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0  
全局区（数据段）|用来存放程序中已初始化的全局变量的一块内存区域
堆heap| new的变量，用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减 
缓冲区| 
栈区stack| 由编译器分配释放,存放函数的参数局部变量的等，用户存放程序临时创建的局部变量。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场  
内核| 内核 

    char *returnStr()
    {
        static char p[] = "hello world!";//虽然是函数内部，但是由于是static，存储在全局区（静态区）
        return p;
    }

    char *returnArray()
    {
        char p[] = "hello world!";//hello world!在只读数据段，但同时在栈上也会开辟一块空间，然后复制进去
        return p;//事实上返回了栈内存
    }

    int main()
    {
        char str1[] = "hello,world";//栈区，运行时赋值
        char str2[] = "hello,world";//栈区

        const char str3[] = "hello,world";
        const char str4[] = "hello,world";

        const char *str5 = "hello,world";//字符串常量，只读常量区
        const char *str6 = "hello,world";//只读常量区

        return 0;
    }


C++使用三种(C++11是四种)存储数据方案，他们区别在于数据保留在内存中的时间。  
**自动存储持续性**：  
  在函数定义中声明的变量(包括函数参数)的存储持续性为自动。随函数或代码块被创建和销毁。    
**静态存储持续性**：函数外定义和static修饰的变量，存储持续性都为静态。它们在程序整个运行过程中都存在。  
  C++为静态存储持续性变量提供了3种链接性：外部链接性(可在其他文件中访问)，内部链接性(只能在当前文件中访问)和无链接性(只能在当前函数或代码块中访问)。  
**线程存储持续性C++11**：  
  使用thread_local声明，其生命周期与所属的线程一样。  
**动态存储持续性**：  
  用new运分配的内存将一直存在，直到使用delete。这种内存的存储持续性为动态，有时被称为自由存储(free store)或堆(heap)。

## 2.作用域和链接 ##    
**链接性**描述了名称如何在不同单元间共享。  
  外部链接性：可在文件间共享。
  内部链接性：只能由一个文件中的函数共享。    
  无链接性：只能在当前函数或代码块访问，如自动变量。  
**作用域**描述了名称在文件的多大范围内可见。  
  作用域为局部的变量只在定义它的代码块中可用。  
  作用域为全局的变量在定义位置到文件结尾之间都可以用。  
  自动变量的作用域为局部。  
  静态变量的作用域是全局还是局部取决于它是如何被定义的。  
  在函数原型作用域中使用的名称只在包含参数列表的括号内可用。  
  在类中声明的成员作用域为整个类。  
  在命名空间中声明的变量的作用域为整个命名空间。  
  C++函数的作用域可以是整个类或整个命名空间，但不能是局部的(因为不能在代码块中定义函数)。      
 
# 变量的存储性和链接性 #
## 3.静态持续变量 ##   
-**静态变量初始化时先将所有位置为0**,然后执行静态初始化或动态初始化。    
-static语义：将修饰对象持续性变为静态。并不允许外部链接性。  
  
| 存储描述 | 持续性 | 作用域 | 链接性 | 如何声明 |
| ------ | ------ | ------ | ------ | ------ |
| 自动 | 自动 | 代码块 | 无 | 在代码块中(可使用关键字auto) |
| 寄存器 | 自动 | 代码块 | 无 | 在代码块中使用register |
| 静态，无链接性 | 静态 | 代码块 | 无 | 在代码块中使用关键字static |
| 静态，外部链接性 | 静态 | 文件 | 外部 | 在函数外面 |
| 静态，内部链接性 | 静态 | 文件 | 内部 | 在函数外面，使用关键字static |


## 4.限定符语义 ##  
static:修饰对象持续性变为静态。并不允许外部链接性（内部链接性或在函数中为无链接性）  
extern：外部链接性，声明引用在其他地方的变量  
thread_local:线程内部变量    
mutable:修饰变量可修改（比如使const类中的成员变得可修改）  
const:常量，值，类和结构的成员等均不能修改。默认修改为外部链接以下（内部链接性或在函数中为无链接性），可用extern修改为外部链接    
volatile:修饰变量禁用缓存寄存器优化    


# 函数的存储持续性和链接性 #  
## 存储持续性 ##  
不允许嵌套定义函数，只能为静态存续性。  
## 链接性 ##  
默认外部性  
static设为内部性  

## 语言链接性 ##  
extern  “[C|C++]” 

## 命名空间使用 ##  
可以替代外部全局变量和内部全局变量  
不在头文件中使用  

## 静态成员和静态成员函数 ##  
可以把类中的静态成员和静态成员函数看作时类的东西，而不是成员的东西，所以它们不能使用this指针等非静态成员和成员函数。  
对象可以访问这些类的静态成员和静态函数。  
