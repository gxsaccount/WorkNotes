string 和 vector 是非常相似的。  

一般不建议在接口中使用 const string&，除非确知调用者已经持有 string：如果函数里不对字符串做复杂处理的话，使用 const char* 可以避免在调用者只有 C 字符串时编译器自动构造 string，这种额外的构造和析构代价并不低。反过来，如果实现较为复杂、希望使用 string 的成员函数的话，那就应该考虑下面的策略：  

如果不修改字符串的内容，使用 const string& 或 C++17 的 string_view 作为参数类型。后者是最理想的情况，因为即使在只有 C 字符串的情况，也不会引发不必要的内存复制。  
如果需要在函数内修改字符串内容、但不影响调用者的该字符串，使用 string 作为参数类型（自动拷贝）。  
如果需要改变调用者的字符串内容，使用 string& 作为参数类型（通常不推荐）。  

默认的std::string
2、COW(Copy-On-Write，写时复制）：当两个std::string发生复制或者赋值时，不会复制字符串内容，而是增加一个引用计数，然后字符串指针进行浅拷贝，其执行效率为O(1)。只有当修改其中一个字符串内容时，才执行真正的复制。即：浅拷贝 + 引用计数。  


https://zhuanlan.zhihu.com/p/348614098  
folly的Fbstring 
3、SSO(Short String Optimization，短字符串优化)：一个程序里用到的字符串大部分都很短小，而在64位机器上，一个char*型指针就占用了8个字节，所以SSO就出现了，其核心思想是发生拷贝时要复制一个指针，对小字符串来说，为啥不直接复制整个字符串呢，说不定还没有复制一个指针的代价大。所以SSO执行的策略就是当字符串的长度小于等于15个字节时，buffer直接存放整个字符串，就是把字符串存放到栈上；当字符串大于15个字节时，buffer存放的就是一个指针，指向堆空间的区域，就是把字符串存放在堆上。
