# 一、序列式容器迭代器失效

  ## 1、顺序容器：  

vector：向量容器。底层是动态开辟的一维数组，内存可增长，每次增长2倍  
deque：双端队列容器。底层是动态开辟的二维数组，一位数组里全部存的是指针，二维数组是动态开辟的，所以说deque的底层是一个部分连续整体不  连续的结构  
list：列表容器。底层是带头节点的双向链表容器  
## 2、对于序列式容器vector、deque  

    当当前元素iterator删除后（就是删除一个元素后），从起始位置到当前删除位置的迭代器是正常的，其后的所有元素的迭代器都会失效，这是因为vector、deque都是连续的存储一段空间，所以当对其进行erase操作时，其后的每一个元素都会向前一个位置。  

 解决办法：当删除元素的时候，必须用erase的返回值更新一些当前的迭代器 比如：it = vec.erase(it);  

 当向容器中添加一个元素的时候，所有的迭代器都失效了（因为随着元素的增加，容器底层的内存可能会扩大所有的迭代器完全失效）  

 解决办法：it = vec.push(it)  

对于deque迭代器失效的总结：  

（1）插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用都会失效  

（2）如果在首位位置添加元素，迭代器会失效，但是指针和引用不会失效  

（3）如果在首位置为之外的任何位置删除元素，那么指向除了被删除元素外其他元素的迭代器全部失效  

（4）在其首部或尾部删除元素则只会使指向被删除元素的迭代器失效  

# 二、关联式容器迭代器失效  

对于关联容器（如map，set，multimap，multiset），删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其它结点造成影响。erase迭代器只是被删除元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。采用这种方法，迭代器就没有问题了  

对erase(it++)的执行过程进行解释：这条语句分为三个步骤，（1）先把iter传值到erase里面，然后iter自增，然后执行erase，所以iter在失效前已经自增了。  
