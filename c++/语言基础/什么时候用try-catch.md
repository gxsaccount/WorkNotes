第一，对错误进行异常处理。所谓错误就是，这里本来不该发生，你却让它发生了，比如传入空指针，数组越界，除数为零。这种时候正确的做法是加断言，或者什么也不做。  
处理这种错误是自作多情而不负责任的，你知道他为啥错了你就给他处理？你处理了只是把鸵鸟脑袋埋进沙子，问题依然存在。底层库没必要为上层程序员的逻辑错误擦屁股。  

第二，认为异常比返回错误码更安全。异常可以直接跳过多层，它必然不如一层层处理安全。如果不配合自动垃圾回收，跳出多层很难保证内存不泄漏，而有gc的语言也难以避免资源泄露。  
因此，不建议处理异常直接跳出多层函数。  
那么异常就没用了吗？当然不是。异常比错误码能够携带更直观的信息，高级语言应该使用异常代替错误码，同时不触及以上误区，则可使程序更健壮。  

作者：知乎用户
链接：https://www.zhihu.com/question/29459586/answer/153318015
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

c++ 的try-catch有性能损耗，需要另作分析  




1. 别人的错，用断言。比如
int randomInt(int lower, int upper)
{
assert(lower <= upper);
// ...
}
定好文档，RTFM。函数被调用时 precondition 没有被满足，不要为上层的失误擦屁股。
2. 只在最外层抛弃详细错误信息，无论是错误码还是异常。
检测到错误以后，要么把错误吞掉当作什么都没发生，要么把错误报告出去，要么继续往上传。但选择继续往上传时，不要让错误消息缩水，比如把错误码变成 bool。
3. 如果代码用于嵌入式、实时系统，或者是并未使用过异常的已有工程，用异常前请三思。
4. 函数正常执行时有且只有一个需要返回的数据，出错时建议用异常。
int generateId();           // 建议出错时抛异常
int generateId();           // 真心不建议用特殊值表示出错，比如 < 0 为错误码
int generateId(int& out)    // 如果你坚持这么做我也没办法
bool generateId(int& out)   // 建议不要这么做。见第二点   

不要为了引入错误码把调用搞复杂。把小于 0 定为错误码相当于用蹩脚的方式实现了 optional，并且没法从签名中看出来，必须借助文档。
5. 与抽象资源相关的错误，用异常。用 RAII 封装这些「资源」，但不要用二段式构造。
理解 RAII。要做到异常安全，RAII 是必不可少的。要实现真正的 RAII，异常是不可或缺的。
6. 只在必要时 catch 异常，比如：
析构函数不能抛出异常：不解释
API 边界：比如动态链接库需要 C 风格接口（此时还需要做异常到错误码的转换）
文档中明确定义不能抛出异常的函数：比如某些操作系统的回调函数
决定报告错误：其实广义而言，也是 API 边界的一种
决定吞掉错误：出这个错无所谓
有从错误中恢复的方法：比如用 UTF-8 解码文本失败，转而尝试用 GBK 解码

