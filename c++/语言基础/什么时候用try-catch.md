第一，对错误进行异常处理。所谓错误就是，这里本来不该发生，你却让它发生了，比如传入空指针，数组越界，除数为零。这种时候正确的做法是加断言，或者什么也不做。  
处理这种错误是自作多情而不负责任的，你知道他为啥错了你就给他处理？你处理了只是把鸵鸟脑袋埋进沙子，问题依然存在。底层库没必要为上层程序员的逻辑错误擦屁股。  

第二，认为异常比返回错误码更安全。异常可以直接跳过多层，它必然不如一层层处理安全。如果不配合自动垃圾回收，跳出多层很难保证内存不泄漏，而有gc的语言也难以避免资源泄露。  
因此，不建议处理异常直接跳出多层函数。  
那么异常就没用了吗？当然不是。异常比错误码能够携带更直观的信息，高级语言应该使用异常代替错误码，同时不触及以上误区，则可使程序更健壮。  

作者：知乎用户
链接：https://www.zhihu.com/question/29459586/answer/153318015
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

c++ 的try-catch有性能损耗，需要另作分析  




1. 别人的错，用断言。比如

    int randomInt(int lower, int upper)
    {
    assert(lower <= upper);
    // ...
    }
定好文档，RTFM。函数被调用时 precondition 没有被满足，不要为上层的失误擦屁股。
2. 只在最外层抛弃详细错误信息，无论是错误码还是异常。
检测到错误以后，要么把错误吞掉当作什么都没发生，要么把错误报告出去，要么继续往上传。但选择继续往上传时，不要让错误消息缩水，比如把错误码变成 bool。
3. 如果代码用于嵌入式、实时系统，或者是并未使用过异常的已有工程，用异常前请三思。
4. 函数正常执行时有且只有一个需要返回的数据，出错时建议用异常。  

    int generateId();           // 建议出错时抛异常  
    int generateId();           // 真心不建议用特殊值表示出错，比如 < 0 为错误码  
    int generateId(int& out)    // 如果你坚持这么做我也没办法  
    bool generateId(int& out)   // 建议不要这么做。见第二点   

不要为了引入错误码把调用搞复杂。把小于 0 定为错误码相当于用蹩脚的方式实现了 optional，并且没法从签名中看出来，必须借助文档。
5. 与抽象资源相关的错误，用异常。用 RAII 封装这些「资源」，但不要用二段式构造。
理解 RAII。要做到异常安全，RAII 是必不可少的。要实现真正的 RAII，异常是不可或缺的。
6. 只在必要时 catch 异常，比如：
析构函数不能抛出异常：不解释
API 边界：比如动态链接库需要 C 风格接口（此时还需要做异常到错误码的转换）
文档中明确定义不能抛出异常的函数：比如某些操作系统的回调函数
决定报告错误：其实广义而言，也是 API 边界的一种
决定吞掉错误：出这个错无所谓
有从错误中恢复的方法：比如用 UTF-8 解码文本失败，转而尝试用 GBK 解码

## 异常安全  ##  
**异常安全：当异常发生时, 既不会发生资源泄露，系统也不会处于一个不一致的状态**  
异常处理并不意味着需要写显式的 try 和 catch。**异常安全的代码，可以没有任何 try 和 catch。**  
今天的主流 C++ 编译器，在异常关闭和开启时应该已经能够产生性能差不多的代码（在异常未抛出时）。  
代价是产生的二进制文件大小的增加，因为异常产生的位置决定了需要如何做栈展开，这些数据需要存储在表里。  
典型情况，使用异常和不使用异常比，二进制文件大小会有约百分之十到二十的上升。  

## 异常的问题 ##  
异常违反了“你不用就不需要付出代价”的 C++ 原则。只要开启了异常，即使不使用异常你编译出的二进制代码通常也会膨胀。  
异常比较隐蔽，不容易看出来哪些地方会发生异常和发生什么异常。  

写异常安全的代码，尤其在模板里。可能的话，提供强异常安全保证 [5]，在任何第三方代码发生异常的情况下，不改变对象的内容，也不产生任何资源泄漏。  
如果你的代码可能抛出异常的话，在文档里明确声明可能发生的异常类型和发生条件。确保使用你的代码的人，能在不检查你的实现的情况，了解需要准备处理哪些异常。  
对于肯定不会抛出异常的代码，将其标为 noexcept。**注意类自动生成的特殊成员函数（构造函数、析构函数、赋值函数等）会自动成为 noexcept，如果它们调用的代码都是 noexcept 的话。所以，像 swap 这样的成员函数应当尽可能标成 noexcept**。  
只有析构函数默认有 noexcept 声明（前提是所有的基类和成员变量的析构函数都 noexcept）。构造函数函数如果不是 default 声明的话，仍需手工标 noexcept。  
最主要是移动构造函数、移动赋值函数和 swap。析构函数也不应该抛异常，但不用标，缺省就是 noexcept。其他函数，能确保没问题的也标一下，特别是很小的返回引用和指针的函数。  

C++ 的标准容器在大部分情况下提供了强异常保证，即，一旦异常发生，现场会恢复到调用函数之前的状态，容器的内容不会发生改变，也没有任何资源泄漏。前面提到过，vector 会在元素类型没有提供保证不抛异常的移动构造函数的情况下，在移动元素时会使用拷贝构造函数。这是因为一旦某个操作发生了异常，被移动的元素已经被破坏，处于只能析构的状态，异常安全性就不能得到保证了。  

虽然对于运行时错误，开发者并没有什么选择余地；但对于代码中的逻辑错误，开发者则是可以选择不同的处理方式的：你可以使用异常，也可以使用 assert，在调试环境中报告错误并中断程序运行。由于测试通常不能覆盖所有的代码和分支，assert 在发布模式下一般被禁用，两者并不是完全的替代关系。在允许异常的情况下，使用异常可以获得在调试和发布模式下都良好、一致的效果。  

程序在编写过程中总会有不正常的情况，处理不正常的情况要么使用错误码各种if/else 还要预防在构造函数里出现不正常现象，要么使用异常，在异常出现后进行try catch最终保证程序无内存泄漏且功能一致。  

 如果你要给非C++的本地客户调用，可能得把异常换成错误码。如果是本地C++调用者，或者是可以处理异常的远程客户，使用异常比使用错误码，调用者的代码更简单。

当然，对于远程调用者，实际上就不能随便抛C++的异常了，必须是事先定义好的明确异常。    

在有虚拟内存的操作系统环境里，你通常不会在分配内存时得到异常（除非你要内存是理论上都不可能满足的）。然后，在你实际使用这些内存时，操作系统才会真正分配物理内存。如果你申请的内存太多了，通常会发生的事情并不是你会得到 bad_alloc 异常，而是你的程序莫名其妙地被系统杀死，或者只是系统慢得像蚂蚁爬，你自己都忍受不下去……  

要在构造函数和运算符重载中表达错误，异常是唯一的方法。  





