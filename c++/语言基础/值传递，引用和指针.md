## 区别 ##  
本质：引用是别名，指针是地址，具体的：  
①从现象上看，**指针在运行时指向的对象（地址）可以改变。引用不能改变**，但是指定的对象其内容可以改变，可以看为不能改变的指针。  
②从内存分配上看，**程序为指针变量分配内存区域，而不为引用分配内存区域**，因为引用声明时必须初始化，从而指向一个已经存在的对象。引用不能指向空值。  
注：标准没有规定引用要不要占用内存，也没有规定引用具体要怎么实现，具体随编译器 http://bbs.csdn.net/topics/320095541  
③ 从编译上看，程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象不能改。这是使用**指针不安全而使用引用安全**的主要原因。从某种意义上来说引用可以被认为是不能改变的指针。  
④不存在指向空值的引用这个事实，意味着使用**引用的代码效率比使用指针的要高**。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。  
⑤理论上，对于指针的**级数**没有限制，但是引用只能是一级。如下：  
  int** p1;         // 合法。指向指针的指针  
  int*& p2;         // 合法。指向指针的引用  
  int&* p3;         // 非法。指向引用的指针是非法的  
  int&& p4;         // 非法。指向引用的引用是非法的  
  注意上述读法是从左到右。   

## 何时使用引用参数 ##  
使用引用参数的主要原因：  
1.程序员能够在函数中修改调用函数参数中的数据对象  
2.通过传递引用而不是整个数据对象，可以提高程序的运行速度。尤其是当数据对象较大时，如结构和类对象。  
**对于使用传递的值而不作修改的函数**  

如果数据对象较小，如内置数据类型或者小型结构，则按值传递。  
如果数据对象是数组，则只能使用指针，并且将指针声明为指向const的指针。  
如果数据对象较大，则使用const指针或者const引用，节省复制结构所需的时间和空间。  
如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用。这是C++增添引用这个特性的主要原因。  

**对于修改调用函数中数据的函数**

如果数据对象是内置数据类型，则使用指针。
如果数据对象是数组，则只能使用指针。
如果数据对象是结构，则使用引用或者指针。
如果数据对象是类对象，则使用引用。
使用引用参数，应尽可能使用const

使用const可以避免无意中修改数据的编程错误。
使用const使得函数能够处理const和非const实参。否则将只能接收非const数据。
使用const引用使函数能够正确生成并使用临时变量。
继承的一个特征是，基类引用可以指向派生类对象，而无需进行强制类型转换。所以，在函数的引用参数设置时，可以定义一个接受基类引用作为参数的函数。调用函数时，可以将派生类对象作为实参。

将基类引用作为参数，编写函数中参数被用到的数据和特性，派生类必定全部都具有。所以派生类对象作为实参，只会使用或修改它从基类继承下来的特性。

而反过来，派生类有很多基类所不具有的特性，将基类对象作为实参，不能提供这些特性，函数无法正常运行。

## 三者在函数调用上的区别 ##
1.值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象或是大的结构体对象，将耗费一定的时间和空间。  
2.指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。  
3.引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。  
