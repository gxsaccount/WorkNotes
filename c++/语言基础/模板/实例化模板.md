不管是类模板还是函数模板，编译器在看到其定义时只能做最基本的语法检查，真正的类型检查要在实例化（instantiation）的时候才能做。  

一般而言，这也是编译器会报错的时候。  

实例化失败的话，编译当然就出错退出了。如果成功的话，模板的实例就产生了。  
在整个的编译过程中，可能产生多个这样的（相同）实例，但最后链接时，会只剩下一个实例。  
这也是为什么 C++ 会有一个单一定义的规则：**如果不同的编译单元看到不同的定义的话，那链接时使用哪个定义是不确定的**，结果就可能会让人吃惊。  

模板还可以显式实例化和外部实例化  


    template cln::cl_I
    my_gcd(cln::cl_I, cln::cl_I);  

那出错信息中的第二行就会显示要求实例化的位置。如果在显式实例化的形式之前加上 extern 的话，编译器就会认为这个模板已经在其他某个地方实例化，从而不再产生其定义（但代码用到的内联函数仍可能会导致实例化的发生，这个会随编译器和优化选项不同而变化）。在我们这个例子里，就意味着不会产生上面的编译错误信息了。当然，我们仍然会在链接时得到错误，因为我们并没有真正实例化这个模板。  


类似的，当我们在使用 vector 这样的表达式时，我们就在隐式地实例化 vector。我们同样也可以选择用 template class vector; 来显式实例化，或使用 extern template class vector; 来告诉编译器不需要实例化。显式实例化和外部实例化通常在大型项目中可以用来集中模板的实例化，从而加速编译过程——不需要在每个用到模板的地方都进行实例化了——但这种方式有额外的管理开销，如果实例化了不必要实例化的模板的话，反而会导致可执行文件变大。因而，显式实例化和外部实例化应当谨慎使用。  



# 特化和重载 #  
对函数使用重载，对类模板进行特化  


# “动态”多态和“静态”多态的对比 #  

以排序为例，C++ 里的标准 sort 算法（以两参数的重载为例）只要求：参数满足随机访问迭代器的要求。迭代器指向的对象之间可以使用 < 来比较大小，满足严格弱序关系。迭代器指向的对象可以被移动。它的性能超出 C 的 qsort，因为编译器可以内联（**inline**）对象的比较操作；而在 C 里面比较只能通过一个额外的函数调用来实现。此外，C 的 qsort 函数要求数组指向的内容是可按比特复制的，C++ 的 sort 则要求迭代器指向的内容是可移动的，可适用于更广的情况。  

C++ 里目前有大量这样的泛型算法。随便列举几个：sort：排序reverse：反转count：计数find：查找max：最大值min：最小值minmax：最小值和最大值next_permutation：下一个排列gcd：最大公约数lcm：最小公倍数等等  



