https://sourceware.org/glibc/wiki/MallocInternals  
https://zhuanlan.zhihu.com/p/443235305  
https://zhuanlan.zhihu.com/p/452291093

# 目录 
* [跳到1. 这是一级标题](#1-Overview of Malloc)  
* [跳到1. 这是一级标题](#1-What is a Chunk?)  
* [跳到1. 这是一级标题](#1-Arenas and Heaps)
* [跳到1. 这是一级标题](#1-Thread Local Cache (tcache))
* [跳到1. 这是一级标题](#1-Malloc Algorithm)
* [跳到1. 这是一级标题](#1-Free Algorithm)
* [跳到1. 这是一级标题](#1-Realloc Algorithm)
* [跳到1. 这是一级标题](#1-Switching arenas)
* [跳到1. 这是一级标题](#1-Detecting heap corruption)
* [跳到1. 这是一级标题](#1-Platform-specific Thresholds and Constants)
* [跳到1. 这是一级标题](#1-TBD)
* [跳到1. 这是一级标题](#1-Colophon)


将malloc、free、coalesce都在一个heap上进行，并在内存中绑定他们  

# 1.Overview of Malloc  
GNU C 库 (glibc) 的 malloc 库包含一些管理应用程序地址空间中分配的内存的函数。 glibc malloc 派生自 ptmalloc (pthreads malloc)，后者派生自 dlmalloc (Doug Lea malloc)。  
此 malloc 是“heap”式 malloc，这意味着不同大小的块存在于更大的内存区域（“堆”）中，而不是使用位图和数组的实现，或相同的区域 -大小块等。  
在以前，每个应用程序有一个堆，但 glibc 的 malloc 允许多个堆，每个堆都在其地址空间内增长。    

因此，在本文档中，我们引用了一些常用术语：  

* Arena  
Arena包含了对一个或多个堆的引用，以及这些堆中“空闲”的块的链接列表，是一种在一个或多个线程之间共享的结构。分配到某个 arena 的线程将从该 arena 的空闲列表中分配内存。  

* Heap  
一个连续的内存区域，被细分为多个块。每个堆属于一个Arena。

* Chunk  
可以分配（由应用程序拥有）、释放（由 glibc 拥有）或与相邻块组合成更大范围的内存范围。请注意，块是提供给应用程序的内存块的包装器。每个块存在于一个堆中并属于一个Arena。

* Memory  
应用程序地址空间的一部分，通常由 RAM 或交换支持。

请注意，在本文档中，我们仅将“内存”作为通用术语。虽然 glibc 的 malloc 中有一些代码可以与 Linux 内核（或其他操作系统）一起使用，用来提示应该映射/支持哪些内存以及可以将哪些内存返回给内核，但除非明确指出，“真实内存”和“虚拟内存”之间的这种区别与本文的讨论无关。  
# 1.What is a Chunk?     
Glibc 的 malloc 是面向块的。它将大的内存区域（“堆”）划分为各种大小的块。每个块都记录它有多大的元数据（通过块头中的大小字段），以及相邻块的位置。当应用程序使用块时，唯一“记住”的数据是块的大小。当块被释放时，曾经是应用程序数据的内存被重新用于其他与Arena相关的信息，例如链接列表中的指针，以便可以在需要时快速找到并重新使用合适的块。此外，空闲块中的最后一个字包含块大小的副本（三个 LSB 设置为零，而块前面的大小的三个 LSB 用于标志）。  

由于所有块都是 8 字节的倍数，因此块大小的 3 个 LSB 可用于标志。这三个标志定义如下：  

* A (0x04)  
已被分配的竞技场 - 主竞技场使用应用程序的堆。其他竞技场使用 mmap 堆。要将块映射到堆，您需要知道适用哪种情况。如果该位为 0，则该块来自主竞技场和主堆。如果该位为 1，则块来自 mmap 的内存，并且堆的位置可以从块的地址计算。  

* M (0x02)  
MMap'd 块 - 这个块是通过对 mmap 的一次调用分配的，根本不是堆的一部分。  

* P (0x01)  
前一个块正在使用 - 如果设置，前一个块仍被应用程序使用，因此 prev_size 字段无效。注意 - 尽管应用程序释放了某些块，例如 fastbins 中的块（见下文），但仍会设置此位。这一点实际上意味着前一个块不应该被视为合并的候选者 - 它被应用程序或其他一些在 malloc 原始代码之上分层的优化“使用中”  

为了确保一个块的有效负载区域足够大以容纳 malloc 所需的开销，一个块的最小大小为 4*sizeof(void*)（除非 size_t 与 void* 大小不同）。如果平台的 ABI 需要额外对齐，则最小尺寸可能会更大。请注意，prev_size 不会将最小块大小增加到 5*sizeof(void*)，因为当块较小时，bk_nextsize 指针未使用，而当块大到可以使用它时，最后有足够的空间。  

[Chunk.png]  

请注意，由于块在内存中彼此相邻，因此如果您知道堆中第一个块的地址（最低地址），则可以使用大小信息遍历堆中的所有块，但只能通过增加地址，尽管可能很难检测到您何时击中了堆中的最后一个块。  

分配的堆总是与 2 的幂地址对齐。因此，当一个块在分配的堆中（即设置了 A 位）时，可以根据该块的地址计算该堆的 heap_info 的地址：  

[heap_info.png]  

# 2.Arenas and Heaps  
为了有效地处理多线程应用程序，glibc 的 malloc 允许一次激活多个内存区域。因此，不同的线程可以访问不同的内存区域而不会相互干扰。这些记忆区域统称为“竞技场”。有一个区域，即“主区域”，对应于应用程序的初始堆。 malloc 代码中有一个静态变量指向这个 arena，每个 arena 都有一个 next 指针来链接其他 arena。  

随着线程碰撞压力的增加，通过 mmap 创建额外的 arena 来缓解压力。 arena 的数量上限是系统中 CPU 数量的 8 倍（除非用户另有说明，请参阅 mallopt），这意味着线程密集的应用程序仍会出现一些争用，但权衡是会更少碎片化。  

每个 arena 结构中都有一个互斥体，用于控制对该 arena 的访问。请注意，某些操作，例如访问 fastbins，可以通过原子操作完成，不需要锁定 arena。所有其他操作都要求线程在 arena 上锁定。对这个互斥体的争用是创建多个 arena 的原因 - 分配给不同 arena 的线程不需要相互等待。如果争用需要，线程将自动切换到未使用（解锁）的竞技场。

每个 arena 从一个或多个堆中获取内存。主arena使用程序的初始堆（在 .bss 等之后开始）。额外的 arena 通过 mmap 为其堆分配内存，当旧的堆用完时，将更多的堆添加到它们的堆列表中。每个 arena 都跟踪一个特殊的“顶部”块，它通常是最大的可用块，也指最近分配的堆。  

分配的 arena 的内存取自该 arena 的初始堆：  

[HeapsAndArenas.png]   

在每个竞技场中，块要么由应用程序使用，要么是免费的（可用）。竞技场不跟踪使用中的块。空闲块根据大小和历史存储在各种列表中，以便库可以快速找到合适的块以满足分配请求。这些列表称为“bins”，包括：  

* Fast  
小块存储在特定大小的箱中。添加到快速 bin（“fastbin”）的块不会与相邻的块组合 - 保持快速访问的逻辑是最小的（因此得名）。 fastbins 中的块可以根据需要移动到其他 bins。 Fastbin 块存储在单链表数组中，因为它们的大小都相同，并且列表中间的块永远不需要访问。
* Unsorted  
当块被释放时，它们最初存储在一个 bin 中。???它们稍后在 malloc 中进行排序，以便给它们一个快速重用的机会???。这也意味着排序逻辑只需要存在于一个点——其他人只需将空闲的块放入这个 bin，它们稍后会被排序。 “unsorted”的 bin 只是常规 bin 中的第一个。
* Small  
正常的 bin 分为“small” bin，“large” bin.每个“small” bin chunk 的大小相同,“large” bin chunk 是一个大小范围。当一个块被添加到这些 bin 中时，它们首先与相邻的块组合以将它们“合并”成更大的块。因此，这些块永远不会与其他此类块相邻（尽管它们可能与快速或未排序的块相邻，当然还有正在使用的块）。小块和大块是双向链表，因此可以从中间删除块（例如当它们与新释放的块组合时）。


* Large  
如果一个块的 bin 可能包含多个大小，则该块是“大”的。对于小箱子，您可以选择第一个块并使用它。对于大型垃圾箱，您必须找到“最佳”块，并可能将其分成两块（一个是您需要的大小，另一个是剩余的）。

[bins.png]  













