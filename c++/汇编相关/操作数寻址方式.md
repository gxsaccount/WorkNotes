https://blog.csdn.net/weixin_40408952/article/details/105628874  
https://cloud.tencent.com/developer/article/1592148  

# x86寻址速查表 #  

![image](https://user-images.githubusercontent.com/20179983/124875380-66d5b900-dffb-11eb-8ae3-ed907ff1f21c.png)

# 寄存器功能速查表 #  
![image](https://user-images.githubusercontent.com/20179983/124875463-84a31e00-dffb-11eb-8ea0-2c9d3ccbabc9.png)


# 七种寻址方式 （小于32位的机器）#
操作数是指令或程序的主要处理对象。如果某条指令或某个程序不处理任何操作数，那么，该指令或程序不可能有数据处理功能。  
在CPU的指令系统中，除NOP(空操作指令)、HLT(停机指令)等少数指令之外，大量的指令在执行过程中都会涉及到操作数。  
所以，在指令中如何表达操作数或操作数所在位置就是正确运用汇编指令的一个重要因素。  

在指令中，指定操作数或操作数存放位置的方法称为寻址方式。  

微机系统有七种基本的寻址方式：
    
操作指令| 对应语句 | 寻址方式
-|-|-
movl %edx,%edx | edx=edx; | register mode  寄存器间接寻址
movl $0x123,%edx|edx=0x123;|immediate 立即数寻址
movl 0x123,%edx| edx = *(int32_t*)0x123; | direct 直接寻址
movl (%ebx),%edx |edx=*(int32_t*)ebx;|indirect  间接寻址
movl 4(%ebx),%edx | edx=*(int32_t*)(ebx+4);| displaced 变址寻址方式（在间接寻址时改变寄存器的数值）


     立即寻址方式、    
     直接寻址方式、
     寄存器寻址方式、
     寄存器间接寻址方式、

    变址寻址方式：
     寄存器相对寻址方式、
     基址加变址寻址方式、
     相对基址加变址寻址方式。
其中，后五种寻址方式是确定内存单元有效地址的五种不同的计算方法，用它们可方便地实现对数组元素的访问。    

另外，在32位微机系统中，为了扩大对存储单元的寻址能力，增加了一种新的寻址方式——32位地址的寻址方式  

为了表达方便，我们用符号“(X)”表示X的值，如：(AX)表示寄存器AX的值。  

助记图： 
![image](https://user-images.githubusercontent.com/20179983/124869677-21fa5400-dff4-11eb-9fc4-191b4e17c6f2.png)


# 1 立即寻址方式: #  
立即数可以是8位、16位或32位，该数值紧跟在操作码之后。如果立即数为16位或32位，那么，它将按“高高低低”的原则进行存储。  
如：  
       MOV AH, 80H　　　ADD AX, 1234H　　　MOV ECX, 123456H
　　　　MOV B1, 12H　　　MOV W1, 3456H　　 ADD D1, 32123456H
其中：B1、W1和D1分别是字节、字和双字单元。  
以上指令中的第二操作数都是立即数，在汇编语言中，规定：立即数不能作为指令中的第二操作数。  
该规定与高级语言中“赋值语句的左边不能是常量”的规定相一致。  

# 2 直接寻址方式: #  
**指令所要的操作数存放在内存中**，在指令中直接给出该操作数的有效地址，这种寻址方式为直接寻址方式。  
在通常情况下，操作数存放在数据段DS中，所以，其物理地址将由数据段寄存器DS和指令中给出的有效地址直接形成，但如果使用段超越前缀，那么，操作数可存放在其它段。  

假设有指令：
      
      MOV BX, [1234H]  

在执行时，(DS)=2000H，内存单元21234H的值为5213H。问该指令执行后，BX的值是什么？  
解：根据直接寻址方式的寻址规则，把该指令的具体执行过程用下图来表示。  
![image](https://user-images.githubusercontent.com/20179983/124869995-9b924200-dff4-11eb-8b6a-d2994b9b387a.png)
由于1234H是一个直接地址，它紧跟在指令的操作码之后，随取指令而被读出；  
访问数据段的段寄存器是DS，所以，**用DS的值和偏移量1234H相加，得存储单元的物理地址：21234H；  
取单元21234H的值5213H，并按“高高低低”的原则存入寄存器BX中。**  
所以，在执行该指令后，BX的值就为5213H。  

# 3 寄存器寻址方式: #  
**操作数在CPU内部的寄存器中**，指令指定寄存器号。  
64位寄存器有：RAX、RBX、RCX、RDX、RSI、RDI、RSP和RBP等。
32位寄存器有：EAX、EBX、ECX、EDX、ESI、EDI、ESP和EBP等。
对于16位操作数，寄存器可以是:AX、BX、CX、DX、SI、DI、SP和BP等。  
对于8位操作数，寄存器可以是AL 、AH、BL、BH、CL、CH、DL、DH。  
这种寻址方式由于操作数就在寄存器中，不需要访问存储器（比如内存）来取得操作数，因而可以取得较高的运算速度。  
如：  
    
    MOV EBX,  12345678H  //目的操作数是寄存器寻址方式
    ADD VARD, EAX　//源操作数是寄存器,VARD、VARW和VARB是双字，字和字节类型的内存变量。  
    MOV EAX, EBX　//源和目的操作数都是寄存器寻址方式  
    
# 4 寄存器间接寻址方式: #  
操作数在寄存器中，操作数有效地址在SI、DI、BX、BP这四个寄存器之一中。  
在不使用段超越前缀的情况下， 
    
    1.如果有效地址在SI、DI和BX中，则以DS段寄存器中的内容为段值。
    2.如果有效地址在BP中，则以SS段寄存器中的内容为段值。  
    
该寻址方式物理地址的计算方法如下：  

![image](https://user-images.githubusercontent.com/20179983/124870256-fdeb4280-dff4-11eb-8a2f-ff7ea03791dc.png)

寄存器间接寻址方式读取存储单元的原理如图所示：  

![image](https://user-images.githubusercontent.com/20179983/124870285-06dc1400-dff5-11eb-9ab2-5287936afc7d.png)

    MOV AX, [DI]
    如果(DS) = 1000H (DI) = 2345H
    则物理地址 = 1000H * 16 + 2345H = 12345H
    12345H地址中的内容为:4354H
    执行该指令后,(AX) = 4354H 
    
 ![image](https://user-images.githubusercontent.com/20179983/124870352-26733c80-dff5-11eb-88b1-094682759211.png)

# 5 寄存器相对寻址方式: #  

操作数在存储器中，操作数的有效地址是一个基址寄存器(BX、BP)或变址寄存器(SI、DI)的内容加上指令中给定的8位或16位位移量之和。  

    BX    8位    位移量
    EA(有效地址) =  BP  + 
    SI    16位    位移量
    DI
在一般情况下，如果SI、DI、或BX中的内容作为有效地址的一部分，那么引用的段寄存器是DS；如果BP中的内容作为有效地址的一部分，那么引用的段寄存器是SS。  
   
    物理地址 = 16d × (DS) + (BX) + 8
          或(SI)或16位位移 
          或(DI)   
    物理地址 = 16d × (SS) + (BP) + 8位位移量
                 或16位位移量
    
    在指令中给定的8位或16位位移量采用补码形式表示。在计算有效地址时，如位移量是8位，则被带符号扩展成16位。
    例如:
    MOV AX,[DI+1223H]
    假设，(DS) = 5000H，(DI) = 3678H
    则物理地址 = 50000 + 3678 + 1233 = 5489BH
    5489BH地址中的内容:55AAH
    执行该指令后AX = 55AAH
    下面指令中，源操作数采用寄存器相对寻址，引用的段寄存器是SS: MOV BX,[BP-4]
    下面指令中，目的操作数采用寄存器相对寻址，引用的段寄存器是ES: MOV ES:[BX+5],AL
    指令:MOV AX,[SI+3]与MOV AX,3[SI]是等价的
    

# 6 基址加变址寻址方式: #  

操作数在寄存器中，操作数的有效地址由:  
基址寄存器之一的内容与变址寄存器之一的内容相加  
  
        BX   SI
    即: EA =  +  
        BP   DI    
在一般情况下，如果BP之内容作为有效地址的一部分，则以SS之内容为段值，否则已DS为段值。  
例如：
    
    MOV AX,[BX][DI]
    如:(DS)=2100H,
       (BX)=0158H,
       (DI)=10A5H
    则EA=0158 + 10A5 = 11FD
    物理地址=21000 + 11FD = 221FDH
    221FDH地址中的内容:1234H
    执行该指令后AX = 1234H
下面指令中，目的操作数采用基址加变址寻址，
引用的段寄存器是DS: MOV DS:[BP+SI],AL

下面指令中，源操作数采用基址加变址寻址，
引用的段寄存器ES: MOV AX,ES:[BX+SI]

这种寻址方式使用与数组或表格处理。用基址寄存器存放数组首地址，而用变地寄存器来定位数组中的各元素，或反之。由于两个寄存器都可改变，所以能更加灵活地访问数组或表格中的元素。
下面的两种表示方法是等价的:
       
       MOV AX,[BX+DI]
       MOV AX,[DI][BX]  

7 相对基址加变址寻址方式:
操作数在存储器中，操作数的有效地址由于基址寄存器之一的内容与变址寄存器之一的内容及指令中给定的8位或16位位移量相加得到。

        BX    SI    8位
    即: EA =     +     +      位移量
        BP    DI    16位

在一般情况下，如果BP中的内容作为有效地址的一部分，则以SS段寄存器中的内容为段值，否则以DS段寄存器中的内容为段值。
在指令中给定的8位或16位位移量采用补码形式示。
在计算有效地址时，如果位移量是8位，那么被带符号扩展成16位。
当所得的有效地址操作FFFFH时，就取其64K的模

例如:
MOV AX,[BX+DI-2]
假设，(DS) = 5000H, (BX) = 1223H, DI = 54H, (51275) = 54H, (51276) = 76H
物理地址= 50000 + 1223 + 0054 + FFFE(-2 各位取反末位加一) = 51275H
执行该指令后 (AX) = 7654H

相对基址加变址这种寻址方式的表示方法多种多样,以下四种方法均是等价的：
MOV AX,[BX+DI+1234H], MOV AX,1234H[BX][DI]
MOV AX 1234H[BX+DI], MOV AX,1234H[DI][BX]


# 32位地址的寻址方式 #  

    在32位微机系统中，除了支持前面的七种寻址方式外，又提供了一种更灵活、方便，但也更复杂的内存寻址方式，从而使内存地址的寻址范围得到了进一步扩大。

　　**在用16位寄存器来访问存储单元时，只能使用基地址寄存器(BX和BP)和变址寄存器(SI和DI)来作为地址偏移量的一部分，但在用32位寄存器寻址时，不存在上述限制，所有32位寄存器(EAX、EBX、ECX、EDX、ESI、EDI、EBP和ESP)都可以是地址偏移量的一个组成部分。**

　　当用32位地址偏移量进行寻址时，内存地址的偏移量可分为三部分：一个32位基址寄存器，一个可乘1、2、4或8的32位变址寄存器，一个8位/32位的偏移常量，并且这三部分还可进行任意组合，省去其中之一或之二。  

　　32位基址寄存器是：EAX、EBX、ECX、EDX、ESI、EDI、EBP和ESP；  
　　32位变址寄存器是：EAX、EBX、ECX、EDX、ESI、EDI和EBP(除ESP之外)。  

　　下面列举几个32位地址寻址指令：

　　　　MOV AX, [123456H]　　　　　　  MOV EAX, [EBX] 
　　　　MOV EBX, [ECX*2]　　　　　　    MOV EBX, [EAX+100H] 
　　　　MOV EDX, [EAX*4+200H]　　　　 MOV EBX, [EAX+EDX*2] 
　　　　MOV EBX, [EAX+EDX*2+300H]　　MOV AX, [ESP]

　　用32位地址偏移量进行寻址的有效地址计算公式归纳如下式所示。  
![image](https://user-images.githubusercontent.com/20179983/124874390-46592f00-dffa-11eb-8b85-5e1a88eea54d.png)  
由于32位寻址方式能使用所有的通用寄存器，所以，和该有效地址相组合的段寄存器也就有新的规定。具体规定如下：   

　　　　1、地址中寄存器的书写顺序决定该寄存器是基址寄存器，还是变址寄存器；  
　　　　2、默认段寄存器的选用取决于基址寄存器；如：[EBX+EBP]中的EBX是基址寄存器，EBP是变址寄存器，而[EBP+EBX]中的EBP是基址寄存器，EBX是变址寄存器；
　　　　3、基址寄存器是EBP或ESP时，默认的段寄存器是SS，否则，默认的段寄存器是DS；
　　　　4、在指令中，如果使用段前缀的方式，那么，显式段寄存器优先。

　　下面列举几个32位地址寻址指令及其内存操作数的段寄存器
指令的举例

访问内存单元所用的段寄存器

MOV  AX, [123456H]  ；默认段寄存器DS

MOV  EAX, [EBX+EBP] ；默认段寄存器DS

MOV  EBX, [EBP+EBX] ；默认段寄存器SS

MOV  EBX, [EAX+100H]

；默认段寄存器DS

MOV  EDX, ES:[EAX*4+200H]

；显式段寄存器ES

MOV  [ESP+EDX*2], AX

；默认段寄存器SS

MOV  EBX, GS:[EAX+EDX*2+300H]

；显式段寄存器GS

MOV  AX, [ESP]

；默认段寄存器SS
