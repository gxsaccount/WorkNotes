迭代器，容器，仿函数都有适配器。适配器使用组合的方式对它们进行改造。 
容器适配器：stack，queue，改造deque


# std::bind #  
1.functions 
2.functions objests
3.member functions,\_1必须时某个object地址
4.data members，\_1必须时某个object地址
5.静态成员函数对象则无需传递（因为静态不属于类？）
    #include <iostream>
    #include <memory>
    #include <functional> 

    using namespace std::placeholders;
    using namespace std;

    void fun1(int n1, int n2, int n3)
    {
        cout << n1 << " " << n2 << " " << n3 << endl;
    }
    
    
    /*普通函数*/
    int main()
    {
        //_1表示这个位置是新的可调用对象的第一个参数的位置
        //_2表示这个位置是新的可调用对象的第二个参数的位置  
        auto f1 = bind(fun1, _2, 22, _1);
        f1(44,55);
    }
    
    
      class A
      {
      public:
          int a;
          void print(int n1, int n2, int n3)
          {
              cout << n1 << " " << n2 << " " << n3 << endl;
          }
      };

      /*成员函数*/
      int main()                                                                                                                                   
      {
          A a;
          //类成员函数需要绑定该类的this指针  
          auto f1 = bind(&A::print, &a, _2, 22, _1);
          auto f2 = bind(&A::print, _1, _2, 22, _3);
          auto f3 = bind(&A::a, _1); //return a.a;
          f1(44,55);
          f2(a,44,55);
      }
