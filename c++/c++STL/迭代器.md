Iterator需要遵循的原则  

# associated_type # 
算法使用迭代器，迭代器需要能够告诉算法的东西:
template<typename T> void algorithem(T first,T last);
1.*T::value_type* 指向数据的类型   
2.*T::iterater_category* 迭代器特性 （iterater的特性，如有的迭代器只能++，不能--）  
3.*T::difference_type* (如interge) 距离定义  
4.T::point_type(未被使用过)
5.T::refence_type(未被使用过)

# iterator traits #   
如果iterator不是class，（native point被视为一种退化的iteractor）  
指针不是类无法回答算法associated_type  
所以需要在算法和指针之间机加上中介层：（traits来萃取相关信息）  

template<typename I> void algorithem(I first,I last){
  typename iterator_trais<I>::value_type;
};  

//I 是 class iteractor
template<typename T>
struct iterator_trais {
  typedef typename T:value_type value_type;
  typedef typename T:iterater_category iterater_category;
  typedef typename T:difference_type difference_type;
  typedef typename T:pointer pointer;
  typedef typename T:reference reference;
}
//I 是 pointer to T
template<typename T>
struct iterator_trais<T*> {
  typedef random_access_iterator_tag iterater_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
}
//I 是 pointer to const T
template<typename T>
struct iterator_trais<const T*> {
  typedef T value_type;//注意是T不是const T
  typedef random_access_iterator_tag iterater_category;//因为是指针，一定是随机访问迭代器
  typedef ptrdiff_t difference_type;//ptrdiff_t类型变量通常用来保存两个指针减法操作的结果。ptrdiff_t定义在stddef.h（cstddef）这个文件内。ptrdiff_t通常被定义为long int类型
  typedef const T* pointer;
  typedef const T& reference;
}
 
1.*iterator_trais<T>::value_type* 指向数据的类型   
2.*iterator_trais<T>::iterater_category* 迭代器特性 （iterater的特性，如有的迭代器只能++，不能--）  
3.*iterator_trais<T>::difference_type* (如interge) 距离定义  
4.iterator_trais<T>::pointer(未被使用过)
5.iterator_trais<T>::reference(未被使用过)
