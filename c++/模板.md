## 模板函数和模板类 ##
1.模板类声明，可以制定多个模板类型和非类型参数  
2.可以设置默认类型  
3.具体化时可以嵌套使用  
4.可以部分实例化

    template<class Type,class Type2 = double,int n=2> class Stack{
      Stack();
      ...
    };//模板类声明，可以制定多个模板类型和非类型参数（int n）;还可以设置默认类型（class Type2 = double）
    template<class Type,class Type2,int n>Stack<Type, Type2, n>:: Stack(){
      ...;
    }//模板函数
    Stack<Stack<myclass,myclass2,9>,class T2,2> s;//可以嵌套使用（Type：Stack<myclass,myclass2,9>）;可以部分实例化（Type2：class T2） 
    
## 模板函数和友元 ##  
1.模板类的非友元模板  
模板函数是所有模板类的友元，一对多关系  

    #include<thread>  
    #include<iostream> 
    #include<string> 
    template<class T> class MyClass{
      private:
      T item ;
      static int ct ;
      public :
      MyClass(const T & i):item(i){ct++;};
      ~MyClass(){ct--;};
      friend void counts();
      friend void reports(MyClass<T> &);
    };

    template<class T> int MyClass<T>::ct = 0;
    void counts(){
      std::cout <<"int"<< MyClass<int>::ct<<" "<<"double"<<MyClass<double>::ct<<std::endl;
    }
    void reports(MyClass<int> & my){
      std::cout << my.item<<std::endl;
    }
    void reports(MyClass<double> & my){
      std::cout << my.item<<std::endl;
    }
    int main(){
      MyClass<int> my1 (10);
      counts();
      MyClass<int> my2(20);
      counts();
      MyClass<double> my3(20.5);
      counts();
      reports(my1);
      reports(my2);
      reports(my3);
    }
    //int1 double0
    //int2 double0
    //int2 double1
    //10
    //20
    //20.5
2.模板类的约束友元函数，带模板类参数  
每种myclass<T>都有各自的友元，是一对一关系。

    //先声明模板
    template<typename T> void counts();
    template<typename T> void reports(T &);

    template<typename TT> class MyClass{
    private:
      TT item ;
      static int ct ;
    public :
      MyClass(const TT & i):item(i){ct++;};
      ~MyClass(){ct--;};
      //友元声明
      friend void counts<TT>();
      friend void reports<>(MyClass<TT> &);
    };

    template<typename T> int MyClass<T>::ct = 0;
    //友元函数实现
    template<typename T> void counts(){
      cout << MyClass<T>::ct<<endl;
    }
    template<typename  T> void reports(T & my){
      cout << my.item<<endl;
    }

    int main(){
      MyClass<int> my1 (10);
      MyClass<int> my2(20);
      counts<int>();
      MyClass<double> my3(30.5);
      counts<double>();
      reports(my1);
      reports(my2);
      reports(my3);
    }
    
3.通用和特定的模板友好声明  
使用模板类本身不同的类型形参，在类内将友元函数声明为模板函数  

    template<class T>
    class ManyFriend{
      private : 
      T item ;
      public:
      ManyFriend(const T & i):item(i){}
      template <class C,class B> friend void show2(C &,B&);
    };
    template<class C,class B>void show2(C&c,B& b){
      std::cout<<c.item<<","<<b.item <<std::endl;
    }
    int main(){
      ManyFriend<int> mf1(10);
      ManyFriend<int> mf2(20);
      ManyFriend<double> mf3(10.5);
      show2(mf1,mf3);
    }
    //2
    //1
    //10
    //20
    //30.5
