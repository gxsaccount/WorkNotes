inter-x86 cpu有四种执行级别，linux只使用了0和3来表示内核态和用户态  


# 如何代码中区分内核态和用户态 #  

    1.cs寄存器的最低两位表明了当前代码的特权级别  
    2.cpu每条指令都是读取cs:eip这两个寄存器（代码段寄存器，偏移量寄存器）  
    3.上述判断由硬件完成  
    4.一般来说（32位），0xc0000000以上的地址空间只能在内核态下访问，0x0000000~0xbfffffff两种状态都能访问，此处位逻辑地址，非物理地址    


# 从用户态切换到内核态 #  
1.必须保存的用户态寄存器上下文  
2.要保存那些 cs:ip,ss:sp,eflags
3.保存在哪 内核堆栈 
  
## 中断处理程序的流程 ##   
中断指令：int  
恢复指令：iret  
步骤：
1、interrupt（ex: int 0x80） - save
cs:eip/ss:eip/eflags(current) to Kernel stack, then load cs:eip(entry of a specific ISR) and ss:eip(point to Kernel stack)
保存用户态栈顶地址ss:esp，当前的状态字eflags，当前的cs:eip的值到内核堆栈  
同时会将ss:esp指向内核态的堆栈地址，内核态的状态字，cs:eip指向当前中断处理程序的入口（对于系统调用指向sys_call函数）

2、SAVE_ALL
  -...//内核代码，完成中断服务，发生进程调度

3、RESTORE_ALL

4、iret - pop cs:eip/ee:eip/eflag from Kernel stack

![image](https://user-images.githubusercontent.com/20179983/130316694-1e7fb2d3-3737-4052-a634-b227681f0d99.png)


## 系统调用 ##  
系统调用是一种特殊的中断  

**系统调用的意义**  
1、操作系统为用户态进程与硬件设备进行交互提供了一组接口-系统调用。把用户从底层的硬件编程中解放出来。


