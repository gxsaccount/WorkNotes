inter-x86 cpu有四种执行级别，linux只使用了0和3来表示内核态和用户态  


# 如何代码中区分内核态和用户态 #  

    1.cs寄存器的最低两位表明了当前代码的特权级别  
    2.cpu每条指令都是读取cs:eip这两个寄存器（代码段寄存器，偏移量寄存器）  
    3.上述判断由硬件完成  
    4.一般来说（32位），0xc0000000以上的地址空间只能在内核态下访问，0x0000000~0xbfffffff两种状态都能访问，此处位逻辑地址，非物理地址    


# 从用户态切换到内核态 #  
1.必须保存的用户态寄存器上下文  
2.要保存那些 cs:ip,ss:sp,eflags
3.保存在哪 内核堆栈 
  
## 中断处理程序的流程 ##   
中断指令：int  
恢复指令：iret  
步骤：
1、interrupt（ex: int 0x80） - save
cs:eip/ss:eip/eflags(current) to Kernel stack, then load cs:eip(entry of a specific ISR) and ss:eip(point to Kernel stack)
保存用户态栈顶地址ss:esp，当前的状态字eflags，当前的cs:eip的值到内核堆栈  
同时会将ss:esp指向内核态的堆栈地址，内核态的状态字，cs:eip指向当前中断处理程序的入口（对于系统调用指向system_call函数）

2、SAVE_ALL
  -...//内核代码，完成中断服务，发生进程调度

3、RESTORE_ALL

4、iret - pop cs:eip/ee:eip/eflag from Kernel stack

![image](https://user-images.githubusercontent.com/20179983/130316694-1e7fb2d3-3737-4052-a634-b227681f0d99.png)


## 系统调用 ##  
系统调用是一种特殊的中断  

**系统调用的意义**  
操作系统为用户态进程与硬件设备进行交互提供了一组接口-系统调用。  
1.把用户从底层的硬件编程中解放出来。  
2.提高系统安全性  
3.程序具备可移植性  

**应用程序接口和系统调用的不同**  
应用编程接口（application program interface，API）和系统调用是不同的。API和系统调用的关系：  
  
      将系统调用封装成一个API接口。  
      系统调用通过软中断向内核发出一个明确的请求（int指令，sys_enter）。  
      
libc库定义的一些API引用了 封装例程（wrapper routine，唯一目的不会汇编指令和使用函数即可触发调用）  
   
   一般每个系统调用对应一个封装例程  
    库再用这些封装例程定义出给用户的API（函数）
不是每个API都对应一个特定的系统调用  

    API可能直接提供用户态服务，如一个数学函数
    一个单独的API可能调用几个系统调用
    不同的API可能调用了同一个系统调用

返回值  

    -大部分封装例程返回一个整数，其值的含义依赖于相应的系统调用
    - -1在多数情况下表示内核不能满足进程的请求
    -libc中定义的errno变量包含特定的出错码

![image](https://user-images.githubusercontent.com/20179983/130317846-41cda52d-4f5b-4e81-8005-c87ec5216aaf.png)

xyz():应用程序编程接口(api)  
0x80：中断处理程序（中断向量）  
sys_xyz():系统函数  


1、当用户态进程调用一个系统调用时，CPU切换到内核态并开始执行一个内核函数  
    
    -Linux中是通过执行int $0x80来执行系统调用的，这条汇编指令产生向量为128的编程异常  
    -intel pentiumII 引入sysenter指令（快速系统调用）  
2、传参  

    -内核实现了很多不同的系统调用，
    -进程必须指明需要哪个系统调用，这需要传递一个名为系统调用号的参数。使用eax寄存器传递。  
3、系统调用也需要输入输出参数，例如：
    
    -实际的值
    -用户态进程地址空间的变量的地址
    -甚至是包含指向用户态函数的指针的数据结构的地址

4、system_call是Linux中所有系统调用的入口点，每个系统调用至少有一个参数，即由eax传递的系统调用号

    -一个应用程序调用fork封装例程，那么在执行int $0x80之前就把eax寄存器的值置为2（即_NR_FORK）。
    -这个寄存器的设置是libc库中的封装例程进行的，因此用户一般不关心系统调用号
    -进入sys_call之后，立即将eax的值压入内核堆栈

5、寄存器传递参数具有如下限制

    -每个参数的长度不能超过寄存器的长度，即32位
    -在系统调用号（eax）之外，参数的个数不能超过6个（ebx、ecx、edx、esi、edi、ebp），超过6个就把每一个寄存器作为一个指针，指向一段内存 进入到内核态之后，可以访问所有的内存地址空间。  



# 实例 #  
        
        //打印当前时间
        #include<stdio.h> 
        #include<time.h> 
        int main(){
            time_t tt;
            struct tm *t;
            tt=time(NULL);
            t=localtime(&tt);
            printf(...);//print 略
            return 0;
        }
        
        
        //嵌入式汇编理解如何调用系统函数  
        #include<stdio.h> 
        #include<time.h>  
        int main(){
            time_t tt;
            struct tm *t;
            asm volatile(
                "mov $0,%%ebx\n\t"   //ebx 清0,相当于time(NULL)的NULL的参数传递（sys_time）
                "mov $0xd,%%eax\n\t"  //通过eax传递需要调用的系统调用编号（13），获取时间  
                "int &0x80\n\t"   //触发中断，进行系统调用 
                "mov %%eax,%0\n\t" //tt=eax
                :"=m"(tt)
            )
            t=localtime(&tt);
            printf(...);//print 略
            return 0;
        }
