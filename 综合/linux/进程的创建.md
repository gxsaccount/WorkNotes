Linux的启动过程：init/main.c内核启动起点
start_kernel函数相当于普通C程序中的main函数，搭建环境，启动内核。  
start_kernel的最后一句rest_init创建0号进程里的kernel_init创建1号进程，  
run_init_process创建1号进程，是第1个用户态进程。pid_kernel_thread(kthreadd,..)用内核线程管理系统资源（创建其他内核服务线程）。
rest_init启动完后，call ..  cpu_idl , call_startup_entry,cpu_idle_loop里面while(1)0号进程，当系统无进程须执行时就调度到idle进程
**道生一（start_kernel....cpu_idle），一生二（kernel_init和kthreadd），二生三（即前面0、1和2三个进程），三生万物（1号进程是所有用户态进程的祖先，2号进程是所有内核线程的祖先）**
Linux在无进程概念的情况下将一直从初始化部分的代码执行到start_kernel，然后再到其最后一个函数调用rest_init。

总之，从rest_init开始，Linux开始产生进程，因为init_task是静态制造出来的，pid=0，它试图将从最早的汇编代码一直到start_kernel的执行都纳入到init_task进程上下文中。  
在rest_init函数中，内核将通过下面的代码产生第一个真正的进程(pid=1):init_idle(current, smp_processor_id())函数的调用就已经把init_task初始化成了一个idle task，  
init_idle函数的第一个参数current就是&init_task，在init_idle中将会把init_task加入到cpu的运行队列中，这样当运行队列中没有别的就绪进程时，  
init_task（也就是idle task)将会被调用，它的核心是一个while(1)循环，在循环中它将会调用schedule函数以便在运行队列中有新进程加入时切换到该新进程上。    

# 1.fork一个进程/用户态创建一个子进程 #
    #include <stdio.h>;
    #include <stdlib.h>;
    #include <unistd.h>;
    int main(int argc, char * argv[])
    {
        int pid;
        /* fork another process */
        pid = fork();
        if (pid < 0) 
        { 
            /* error occurred */
            fprintf(stderr,"Fork Failed!");
            exit(-1);
        } 
        else if (pid == 0) 
        {
            /* child process */
            printf("This is Child Process!\n");
        } 
        else 
        {     
            /* parent process     */
            printf("This is Parent Process!\n");
            /* parent will wait for the child to complete*/
            wait(NULL);
            printf("Child Complete!\n");
        }
    }


