![image](https://user-images.githubusercontent.com/20179983/131761086-7611bf28-7913-408c-b37e-6ff10153a231.png)    
1.用户空间： 
通过malloc和free进行内存管理，默认使用glic的ptmalloc。ptmalloc使用系统调用brk和mmap向内核以**页**为单位申请内存。此外还有tcmalloc和jemalloc。  
2.内核空间：  
基本功能：
虚拟内存管理:负责给进程虚拟空间分配虚拟页，sys_brk用来扩大或收缩堆，sys_mmap用来在内存映射区域分配虚拟页，sys_munmap用来释放虚拟页。  
页分配器（伙伴系统）：用来分配物理页  
块分配器：将页划分为小块。根据kmalloc()/kfree()接口进行。支持3个块分配器：slab、slob、slub  
扩展功能：  
不连续页分配器：在内存碎片过多时，申请连续的物理空间成功率低，可以申请不连续的物理空间，映射到连续的虚拟页（虚拟地址连续，物理地址不连续）。使用不连续页分配器接口vmalloc()和vfree()  
连续页分配器（CMA）: 用来给驱动预留一段连续内存，驱动不使用时可以给进程使用。驱动需要时将进程占用空间通过**回收和迁移**拿回内存。当内存碎片导致无连续内存时通过内存紧缩，利用迁移得到连续内存。  
3.硬件层面：  
处理器内存管理单元（MMU），负责虚拟地址到物理地址的转化。MMU包含一个页表缓存TLB部件。  
4.虚拟地址空间布局  
32位系统：  
4GB 的进程虚拟地址空间被分成两部分：「用户空间」和「内核空间」，如下图所示：  
![image](https://user-images.githubusercontent.com/20179983/132113401-a0a06bc5-6d7d-46dc-91da-869a877d2d0b.png)

64位系统：  
arm64处理器不支持完全的64位虚拟地址。虚拟地址最大为48位。内核虚拟地址高16位均为1，范围是[0xFFFF 0000 0000 0000,0xFFFF FFFF FFFF FFFF]  
用户地址空间，高16位全是0，范围是[0x0000 0000 0000 0000,0x0000 FFFF FFFF FFFF]   

![image](https://user-images.githubusercontent.com/20179983/132113042-83d52fcd-f2e9-4bd5-b8d5-9109431cddaa.png)

编译arm64的linux内核可以选择的虚拟地址宽度：  

  选择页长度4KB，默认虚拟地址宽度39位
  选择页长度16KB，默认虚拟地址宽度47位
  选择页长度64KB，默认虚拟地址宽度42位
  也可以选择48位虚拟地址空间  
在arm64的linux内核中，内存虚拟地址和用户虚拟地址宽度相同  

5.用户虚拟地址空间布局  
进程用户虚拟地址空间的起始地址位为0，长度是TASK_SIZE,由每种CPU架构TASK_SIZE定义。    
主要空间如下：  
1.代码段，数据段，未初始化数据段
2.动态库代码段，代码段，数据段，未初始化数据段  
3.堆  
4.栈  
5.存放在栈底部的环境变量和参数字符串  
6.内存映射区：把文件区间映射到虚拟地址空间，使用内存描述符mm_struct描述进程的用户虚拟地址空间  





