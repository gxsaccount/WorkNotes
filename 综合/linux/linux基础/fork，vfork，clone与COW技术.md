Linux的用户进程不能直接被创建出来，因为不存在这样的API。它只能从某个进程中复制出来，再通过exec这样的API来切换到实际想要运行的程序文件。  
复制的API包括三种：fork、clone、vfork。  
这三个API的内部实际都是调用一个内核内部函数do_fork，只是填写的参数不同而已。  

##进程的四要素：##

    （1）有一段程序供其执行（不一定是一个进程所专有的），就像一场戏必须有自己的剧本。
    （2）有自己的专用系统堆栈空间（私有财产）
    （3）有进程控制块（task_struct）（“有身份证，PID”）
    （4）有独立的存储空间。

**缺少第四条的称为线程，如果完全没有用户空间称为内核线程，共享用户空间的称为用户线程。**  

## fork ##
在四项资源的复制中，用户空间是相对庞大的，如果完全复制则效率会很低。  
在Linux中采用的**写时复制**技术，也就是说，fork执行时并不真正复制用户空间的所有页面，而只是复制页面表。  
这样，无论父进程还是子进程，当发生用户空间的写操作时，都会引发“写复制”操作，而另行分配一块可用的用户空间，使其完全独立。  
这是一种提高效率的非常有效的方法。  



## vfork ##
vfork是一个过时的应用，vfork也是创建一个子进程，但是子进程共享父进程的空间。  
在vfork创建子进程之后，父进程阻塞，直到子进程执行了exec()或者exit()。  
vfork最初是因为fork没有实现COW机制，而很多情况下fork之后会紧接着exec，而exec的执行相当于之前fork复制的空间全部变成了无用功（原有的数据会被修改以实现子进程自己的功能)），所以设计了vfork。  
而现在fork使用了COW机制，唯一的代价仅仅是复制父进程页表的代价，所以vfork不应该出现在新的代码之中。  
vfork创建出来的不是真正意义上的进程，而是一个线程，因为它缺少独立的内存资源。  
vfork创建出的子进程（线程）共享了父进程的count变量，这一次是指针复制，2者的指针指向了同一个内存，所以子进程修改了count变量,父进程的 count变量同样受到了影响。
另外由vfork创建的子进程要先于父进程执行，子进程执行时，父进程处于挂起状态，子进程执行完，唤醒父进程。  
**除非子进程exit或者execve才会唤起父进程。**  

## clone ##  
**clone是Linux为创建线程设计的（虽然也可以用clone创建进程）**。  
所以可以说clone是fork的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等。
clone函数功能强大，带了众多参数，它提供了一个非常灵活自由的常见进程的方法。因此由他创建的进程要比前面2种方法要复杂。  
clone可以让你有选择性的继承父进程的资源，你可以选择想vfork一样和父进程共享一个虚存空间，从而使创造的是线程，你也可以不和父进程共享，你甚至可以选择创造出来的进程和父进程不再是父子关系，而是兄弟关系。  

## clone和fork的区别：##  
（1） clone和fork的调用方式很不相同，**clone调用需要传入一个函数，该函数在子进程中执行**。  
（2）clone和fork最大不同在于**clone不再复制父进程的栈空间，而是自己创建一个新的**。 
（void \*child_stack,）也就是第二个参数，需要分配栈指针的空间大小，所以它不再是继承或者复制，而是全新的创造。   




## copy on write ##  
linux 的 Copy On Write：    

    1.fork创建出的子进程，与父进程共享内存空间。  
    2.如果子进程不对内存空间进行写入操作的话，内存空间中的数据并不会复制给子进程，这样创建子进程的速度就很快了！(不用复制，直接引用父进程的物理空间)。  
    3.如果在fork函数返回之后，子进程第一时间exec一个新的可执行映像，那么也不会浪费时间和内存空间了。
另外的表达方式：
    
    1.在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。
    当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。
    2.如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。
    而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。

**Copy On Write技术实现原理：**  

    1.fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。  
    2.当父子进程都只读内存时，相安无事。  
    3.当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。  
    4.中断例程中，kernel就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份。  

**Copy On Write技术好处是什么？**  

    COW技术可减少分配和复制大量资源时带来的瞬间延时。
    COW技术可减少不必要的资源分配。比如fork进程时，并不是所有的页面都需要复制，父进程的代码段和只读数据段都不被允许修改，所以无需复制。

**Copy On Write技术缺点是什么？**

    如果在fork()之后，父子进程都还需要继续进行写操作，那么会产生大量的分页错误(页异常中断page-fault)，这样就得不偿失。

几句话总结Linux的Copy On Write技术：  
fork出的子进程共享父进程的物理空间，当父子进程有内存写入操作时，read-only内存页发生中断，将触发的异常的内存页复制一份(其余的页还是共享父进程的)。  
fork出的子进程功能实现和父进程是一样的。如果有需要，我们会用exec()把当前进程映像替换成新的进程文件，完成自己想要实现的功能。  
