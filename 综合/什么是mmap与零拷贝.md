# 传统IO #
基于传统的IO方式，底层实际上通过调用read()和write()来实现。  
通过read()把数据从硬盘读取到内核缓冲区，再复制到用户缓冲区；然后再通过write()写入到socket缓冲区，最后写入网卡设备。  

整个过程发生了**4次用户态和内核态的上下文切换**和**4次拷贝**，具体流程如下：
    
  1.用户进程通过read()方法向操作系统发起调用，此时上下文从*用户态转向内核态*  
  2.DMA控制器把数据从**硬盘拷贝到读缓冲区**  
  3.CPU把**读缓冲区数据拷贝到应用缓冲区**，上下文从*内核态转为用户态*，read()返回  
  4.用户进程通过write()方法发起调用，上下文从*用户态转为内核态*  
  5.CPU将**应用缓冲区中数据拷贝到socket缓冲区**  
  6.DMA控制器把数据从**socket缓冲区拷贝到网卡**，上下文从*内核态切换回用户态*，write()返回  
  ![image](https://user-images.githubusercontent.com/20179983/114532977-fb8c7d00-9c7f-11eb-8a4a-42261197dfca.png)

# 零拷贝 #  
减少cup拷贝。  

常见的零拷贝技术
## mmap+write ##
mmap+write简单来说就是使用mmap替换了read+write中的read操作，减少了一次CPU的拷贝。
mmap主要实现方式是将**读缓冲区的地址和用户缓冲区的地址进行映射**，内核缓冲区和应用缓冲区共享，从而减少了从**读缓冲区到用户缓冲区的一次CPU拷贝**。  

![image](https://user-images.githubusercontent.com/20179983/114533294-532ae880-9c80-11eb-858f-9ddfbe615701.png)  
整个过程发生了**4次用户态和内核态的上下文切换**和**3次拷贝**，具体流程如下：  
  1.用户进程通过mmap()方法向操作系统发起调用，上下文从*用户态转向内核态*  
  2.DMA控制器把数据从**硬盘中拷贝到读缓冲区**    
  3.上下文从*内核态转为用户态*，mmap调用返回  
  4.用户进程通过write()方法发起调用，上下文从*用户态转为内核态*  
  5.CPU将**读缓冲区中数据拷贝到socket缓冲区**  
  6.DMA控制器把数据从**socket缓冲区拷贝到网卡**，上下文从内核态切换回用户态，write()返回

mmap的方式节省了一次CPU拷贝，同时由于用户进程中的内存是虚拟的，只是映射到内核的读缓冲区，所以可以节省一半的内存空间，比较适合大文件的传输。  

# sendfile #  
相比mmap来说，sendfile同样减少了一次CPU拷贝，而且还减少了2次上下文切换。

    #include<sys/sendfile.h>  
    ssize_t sendfile(int out_fd,int in_fd,off_t *offset,size_t count);  
sendfile是Linux2.1内核版本后引入的一个系统调用函数，通过使用sendfile数据可以直接在内核空间进行传输，因此避免了用户空间和内核空间的拷贝.  
同时由于使用sendfile替代了read+write从而节省了一次系统调用，也就是2次上下文切换。     
![image](https://user-images.githubusercontent.com/20179983/114533810-e2d09700-9c80-11eb-9ec7-eb62b4d84a2b.png)  
整个过程发生了**2次用户态和内核态的上下文切换**和**3次拷贝**，具体流程如下：  

  1.用户进程通过sendfile()方法向操作系统发起调用，上下文从*用户态转向内核态*    
  2.DMA控制器把数据从**硬盘中拷贝到读缓冲区**  
  3.CPU将**读缓冲区中数据拷贝到socket缓冲区**  
  4.DMA控制器把数据从**socket缓冲区拷贝到网卡**，上下文从*内核态切换回用户态*，sendfile调用返回  

 sendfile方法IO数据对用户空间完全不可见，所以只能适用于完全不需要用户空间处理的情况，比如静态文件服务器。  
 
 
# sendfile+DMA Scatter/Gather #    
Linux2.4内核版本之后对sendfile做了进一步优化，通过引入新的硬件支持，这个方式叫做DMA Scatter/Gather 分散/收集功能。    
它将读缓冲区中的数据描述信息--内存地址和偏移量记录到socket缓冲区，由 DMA 根据这些将数据从读缓冲区拷贝到网卡，相比之前版本减少了一次CPU拷贝的过程    
![image](https://user-images.githubusercontent.com/20179983/114534130-3cd15c80-9c81-11eb-88dd-78a952260c0f.png)    
整个过程发生了**2次用户态和内核态的上下文切换**和**2次拷贝**，其中更重要的是完全没有CPU拷贝，具体流程如下：   
  1.用户进程通过sendfile()方法向操作系统发起调用，上下文从*用户态转向内核态*  
  2.DMA控制器利用scatter把数据从**硬盘中拷贝到读缓冲区离散存储**  
  3.CPU把读缓冲区中的文件描述符和数据长度发送到socket缓冲区  
  4.DMA控制器根据文件描述符和数据长度，使用scatter/gather把数据从**内核缓冲区拷贝到网卡**  
  5.sendfile()调用返回，上下文从*内核态切换回用户态*  
DMA gather和sendfile一样数据对用户空间不可见，而且需要硬件支持，同时输入文件描述符只能是文件，但是过程中完全没有CPU拷贝过程，极大提升了性能。  

# 总结 #
由于CPU和IO速度的差异问题，产生了DMA技术，通过DMA搬运来减少CPU的等待时间。  
传统的IOread+write方式会产生2次DMA拷贝+2次CPU拷贝，同时有4次上下文切换。  
而通过mmap+write方式则产生2次DMA拷贝+1次CPU拷贝，4次上下文切换，通过内存映射减少了一次CPU拷贝，可以减少内存使用，适合大文件的传输。  
sendfile方式是新增的一个系统调用函数，产生2次DMA拷贝+1次CPU拷贝，但是只有2次上下文切换。因为只有一次调用，减少了上下文的切换，但是用户空间对IO数据不可见，适用于静态文件服务器。  
sendfile+DMA gather方式产生2次DMA拷贝，没有CPU拷贝，而且也只有2次上下文切换。虽然极大地提升了性能，但是需要依赖新的硬件设备支持。  


 
