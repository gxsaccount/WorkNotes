Docker 是“新瓶装旧酒”的产物，依赖于 Linux 内核技术 unionFS，namespace 和 cgroup等技术。  
cgroup：
  
   CGroups 全称control group，用来限定一个进程的资源使用，由Linux 内核支持，可以限制和隔离Linux进程组 (process groups) 所使用的**物理资源** ，比如cpu，内存，磁盘和网络IO，是Linux container技术的物理基础。

namespace：
  另一个维度的资源隔离技术，大家可以把这个概念和我们熟悉的C++和Java里的namespace相对照。  
  如果CGroup设计出来的目的是为了隔离上面描述的物理资源，那么**namespace则用来隔离PID(进程ID),IPC,Network等系统资源**。   
  这些系统资源可以将它们分配给特定的Namespace，每个Namespace里面的资源对其他Namespace都是透明的。  
  不同container内的进程属于不同的Namespace，彼此透明，互不干扰。  
  Linux操作系统到目前为止支持的六种namespace：
  ![image](https://user-images.githubusercontent.com/20179983/130415780-de138a5e-48f6-4330-9197-daf759701889.png)  
unionFS：  
顾名思义，unionFS可以把文件系统上多个目录(也叫分支)内容联合挂载到同一个目录下，而目录的物理位置是分开的。  
1. boot file system （bootfs）：包含操作系统boot loader 和 kernel。用户不会修改这个文件系统。一旦启动完成后，整个Linux内核加载进内存，之后bootfs会被卸载掉，从而释放出内存。同样内核版本的不同的 Linux 发行版，其bootfs都是一致的。    
2. root file system （rootfs）：包含典型的目录结构，包括 /dev, /proc, /bin, /etc, /lib, /usr, and /tmp  
Linux 系统在启动时，roofs 首先会被挂载为只读模式，然后在启动完成后被修改为读写模式，随后它们就可以被修改了。  
不同的Linux版本，实现unionFS的技术可能不一样，使用命令docker info查看Storage Driver，查看实现技术  

  使用sudo mount **-t aufs** -o dirs=./abap:./java none ./mnt 进行测试  
  在java文件中进行改动，mnt也会改变，反之不行  
  
  **实际上这就是Docker容器镜像分层（容器 Copy-on-Write 特性）实现的技术基础。** 这种分层设计，一个优点就是资源共享。  
  容器镜像由多个镜像层组成，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如 /text，上层的 /text 会覆盖下层的 /text，也就是说用户只能访问到上层中的文件 /text。  
  当用docker run启动这个容器时，实际上在镜像的顶部添加了一个新的可写层。这个可写层也叫容器层。  
  
和虚拟机的区别  
![image](https://user-images.githubusercontent.com/20179983/140004695-7ded1ae3-c986-432d-8490-526cf4e40ae8.png)
虚拟机：  
，名为 Hypervisor 的软件是虚拟机最主要的部
分。它通过硬件虚拟化功能，模拟出了运行一个操作系统需要的各种硬件，比如 CPU、内存、
I/O 设备等等。然后，它在这些虚拟的硬件上安装了一个新的操作系统，即 Guest OS。
这样，用户的应用进程就可以运行在这个虚拟的机器中，它能看到的自然也只有 Guest OS 的文
件和目录，以及这个机器里的虚拟设备。这就是为什么虚拟机也能起到将不同的应用进程相互隔
离的作用。  

docker：  
真正对隔离环境负责的是宿主机操作系统本身   


根据实验，一个运行着 CentOS 的 KVM 虚拟机启动后，在不做优化的情况下，虚拟机自己就
需要占用 100~200 MB 内存。此外，用户应用运行在虚拟机里面，它对宿主机操作系统的调用
就不可避免地要经过虚拟化软件的拦截和处理，这本身又是一层性能损耗，尤其对计算资源、网
络和磁盘 I/O 的损耗非常大。
而相比之下，容器化后的用户应用，却依然还是一个宿主机上的普通进程，这就意味着这些因为
虚拟化而带来的性能损耗都是不存在的；而另一方面，使用 Namespace 作为隔离手段的容器
并不需要单独的 Guest OS，这就使得容器额外的资源占用几乎可以忽略不计。
所以说，“敏捷”和“高性能”是容器相较于虚拟机最大的优势，也是它能够在 PaaS 这种更细
粒度的资源管理平台上大行其道的重要原因。


不过，有利就有弊，基于 Linux Namespace 的隔离机制相比于虚拟化技术也有很多不足之处，
其中最主要的问题就是：隔离得不彻底。
首先，既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个
宿主机的操作系统内核。
尽管你可以在容器里通过 Mount Namespace 单独挂载其他不同版本的操作系统文件，比如
CentOS 或者 Ubuntu，但这并不能改变共享宿主机内核的事实。这意味着，如果你要在
Windows 宿主机上运行 Linux 容器，或者在低版本的 Linux 宿主机上运行高版本的 Linux 容
器，都是行不通的。
而相比之下，拥有硬件虚拟化技术和独立 Guest OS 的虚拟机就要方便得多了。最


其次，在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：
时间。
这就意味着，如果你的容器中的程序使用 settimeofday(2) 系统调用修改了时间，整个宿主机
的时间都会被随之修改，这显然不符合用户的预期。相比于在虚拟机里面可以随便折腾的自由
度，在容器里部署应用的时候，“什么能做，什么不能做”，就是用户必须考虑的一个问题。
此外，由于上述问题，尤其是共享宿主机内核的事实，容器给应用暴露出来的攻击面是相当大
的，应用“越狱”的难度自然也比虚拟机低得多。
更为棘手的是，尽管在实践中我们确实可以使用 Seccomp 等技术，对容器内部发起的所有系统
调用进行过滤和甄别来进行安全加固，但这种方法因为多了一层对系统调用的过滤，一定会拖累
容器的性能。何况，默认情况下，谁也不知道到底该开启哪些系统调用，禁止哪些系统调用。
所以，在生产环境中，没有人敢把运行在物理机上的 Linux 容器直接暴露到公网上。当然，我
后续会讲到的基于虚拟化或者独立内核技术的容器实现，则可以比较好地在隔离与性能之间做出
平衡  
