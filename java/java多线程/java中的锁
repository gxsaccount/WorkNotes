volatile：只有可见性，有序性没有原子性。volatile关键字禁止指令重排序。加入volatile关键字时，会多出一个lock前缀指令（内存屏障）。
synchronized：悲观锁，重锁，可重入锁。同步块形成monitorenter和moniterexit字节码指令。根据对象参数锁对象。或根据修饰方式锁实例或者Class对象。
ReentrantLock：悲观锁，重锁，可重入锁。通过lock()和unlock()与try...catch来使用。有一些高级特性：等待可中断，可公平锁，锁可以绑定多个Condition。
并发性低，用synchronized，高用ReentrantLock。1.6后持平。建议用synchronized。
CAS操作：乐观锁。三个参数：内存位置，预期值，新值。ABA问题不安全。
原子类：如AtomicInteger，更新使用CAS操作，有原子性。
ThreadLocal：线程本地存储。通过一个Map找到本地线程变量。

锁优化
自旋锁：大部分锁不会占用太长时间，让请求锁的线程自旋，节约线程挂起和恢复开销。
锁消除：编译时检测不需要同步。依据逃逸分析结果。
锁粗化：一系列连续操作对同一个对象加锁解锁，会将锁扩展到连续操作的整个范围，防止频繁的加解锁。如循环中加解锁。
轻量锁：在没有多线程竞争下，使用CAS减少重锁使用操作系统互斥量的消耗。
偏向锁：在没有多线程竞争下，把整个同分消除。偏向于第一个请求的线程，执行中，若每没有其他线程获取此锁，持有偏向锁的线程永远不需要同步。
        因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令。 

偏向锁执行过程：
1.当锁对象第一次被线程获取时，对象头中的锁标志变为01（偏向模式）
2.使用CAS将线程id记录在对象的MarkWord中，该线程再进入时可以没有同步操作。
3.有另外一个线程竞争时，锁对象处于被锁->锁标志01或00，
4.轻量锁执行

轻量锁执行过程：
加锁：
1.代码进入同分块时，若同步对象没有被锁定(锁标志为01)，虚拟机建立一个锁记录空间，存锁对象的MarkWord拷贝。
2.用CAS操作尝试将对象的MarkWord更新为指向锁记录空间的指针。成功MarkWord锁标志变为00。
3.失败虚拟机检查MarkWord是否指向当前线程的栈帧。是，说明已经有了该对象的锁。不是，说明被抢占了。轻量锁变为重锁。锁标志变为10.
解锁：
CAS将当前对象的MarkWord和拷贝的MarkWord换回来。

重锁执行过程：
重量级锁的加锁（锁标志10）、解锁过程和轻量级锁差不多，区别是：MarkWord指向互斥量，竞争失败后，线程阻塞，释放锁后，唤醒阻塞的线程，不使用自旋锁，不会那么消耗CPU，所以重量级锁适合用在同步块执行时间长的情况下。
