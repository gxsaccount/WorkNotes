内存泄露场景：

1。数据库连接、io、等资源对象未关闭。
  try catch后，在finally方法中关闭连接。

2。native方法。

3。静态集合类引起内存泄露：
  静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object（就算对象Object引用=null了也没用）也不能被释放，因为他们也将一直被Vector等引用着。
  如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。
  或者用WeakHashMap这样的弱引用。

4。非静态内部类持有外部引用可能会内存泄露：
  使用静态内部类/匿名类，不要使用非静态内部类/匿名类.非静态内部类/匿名类会隐式的持有外部类的引用，外部类就有可能发生泄漏。而静态内部类/匿名类不会隐式
的持有外部类引用，外部类会以正常的方式回收，
  如果你想在静态内部类/匿名类中使用外部类的属性或方法时，可以显示的持有一个弱引用，引入弱引用，弱引用可以只能存在到引用GC触发之前，不会影响内存的回  
收。

5。当集合里面的对象属性被修改后，再调用remove（）方法时不起作用。

6。单例模式，当单例模式的对象是一个集合类或者持有其他引用时。

7。常量池的字符串过多是内存泄露的原因之一。

8。classloader，有时候有些对象会防不胜防地引用到classloader，这样gc就无法对其进行回收

用JRockit Management Console。
    
